✔ 1.1 Reconcile Board Representation Conflicts @done(25-12-06 12:40)
 ✔ Decision: Choose between two conflicting board representations: Current CBoard uses separate bitboards (whitePawns, blackPawns, etc.) OR use the pieces[color][pieceType] array structure @done(25-12-06 12:41)
 ✔ Update cboard.h to use consistent representation throughout @done(25-12-06 12:41)
 ✔ Update recomputeOccupancies() to match chosen structure @done(25-12-06 12:41)
 ✔ Ensure colorPieces[WHITE] and colorPieces[BLACK] are properly maintained @done(25-12-06 12:41)
 ✔ Add sideToMove field to CBoard (currently using whiteToMove bool) @done(25-12-06 12:41)
 ✔ Standardize color enum: use WHITE=0, BLACK=1 or WHITE=1, BLACK=0 consistently @done(25-12-06 12:41)
✔ 1.2 Reconcile Move Structure Conflicts @done(25-12-06 14:20)
 ✔ Decision: Choose between two move structures: move.h has Move with fromSquare, toSquare, type (12+ bytes) Suggested compact encoding uses 16-bit Move with bit-packed fields (2 bytes) @done(25-12-06 14:20)
 ✔ Update move.h with final chosen structure @done(25-12-06 14:20)
 ✔ Define clear move encoding scheme (which bits mean what) @done(25-12-06 14:20)
✔ 1.3 Add Missing Helper Functions to bitboard.h @done(25-12-06 14:22)
 ✔ Add getLSB(Bitboard) function to get least significant bit position @done(25-12-06 14:22)
 ✔ Add popLSB(Bitboard*) function to pop and return LSB, modifying bitboard in place @done(25-12-06 14:22)
 ✔ Verify bb_pop_lsb() works correctlåy (currently returns -1 on empty, decide if that's desired) @done(25-12-06 14:22)
 ✔ Add clearBit(Bitboard*, Square) convenienåce function @done(25-12-06 14:22)
 ✔ Add setBit(Bitboard*, Square) convenience function @done(25-12-06 14:22)
Phase 2: Complete Move Encoding System

✔ 2.2 Create Move Construction Macros/Functions @done(25-12-06 14:33)
 ✔ Write MAKE_MOVE(from, to) for quiet moves @done(25-12-06 14:33)
 ✔ Write MAKE_CAPTURE(from, to) for captures @done(25-12-06 14:33)
 ✔ Write MAKE_PROMOTION(from, to, piece) for promotions @done(25-12-06 14:33)
 ✔ Write MAKE_PROMOTION_CAPTURE(from, to, piece) for promotion captures @done(25-12-06 14:33)
 ✔ Write MAKE_EN_PASSANT(from, to) for en passant @done(25-12-06 14:33)
 ✔ Write MAKE_CASTLING(from, to) for castling moves @done(25-12-06 14:33)
 ✔ Write MAKE_DOUBLE_PAWN_PUSH(from, to) for double pawn pushes @done(25-12-06 14:33)
2.3 Create Move Extraction Macros/Functions
 Write GET_FROM(move) to extract source square
 Write GET_TO(move) to extract destination square
 Write GET_PROMOTION_PIECE(move) to extract promotion piece type
 Write GET_FLAGS(move) to extract special move flags
 Write IS_CAPTURE(move) predicate
 Write IS_PROMOTION(move) predicate
 Write IS_EN_PASSANT(move) predicate
 Write IS_CASTLING(move) predicate
 Write IS_DOUBLE_PUSH(move) predicate
Phase 3: Implement Pseudo-Legal Move Generation
3.1 Pawn Move Generation
 Single pushes:
Get all pawns for side to move
Shift forward by 8 (white) or -8 (black)
Mask with empty squares
For each resulting square, create move
 Double pushes:
Start with single pushes that land on rank 3 (white) or rank 6 (black)
Shift forward again
Mask with empty squares
Create moves with double-push flag
 Captures left:
Shift pawns diagonally left-forward
Mask with opponent pieces
Create capture moves for each hit
 Captures right:
Shift pawns diagonally right-forward
Mask with opponent pieces
Create capture moves for each hit
 Promotions:
Detect when pawn reaches rank 7 (white) or rank 2 (black)
Generate 4 moves per promotion (N/B/R/Q)
Handle both promotion pushes and promotion captures
 En passant:
Check if epSquare is valid (not 64 or -1)
Check if any pawn can attack the en passant square
Generate en passant capture move with special flag
3.2 Knight Move Generation
 Get all knights for side to move
 For each knight:
Use precomputed getKnightAttacks(square) lookup
Mask out friendly pieces
For each set bit in resulting attack bitboard:
Determine if it's a capture (intersects enemy pieces)
Create appropriate move type
Add to move list
3.3 Bishop Move Generation
 Get all bishops for side to move
 For each bishop:
Call getBishopAttacks(square, occupancy) with current board occupancy
Mask out friendly pieces
For each set bit in resulting attack bitboard:
Determine if capture or quiet move
Create move and add to list
3.4 Rook Move Generation
 Get all rooks for side to move
 For each rook:
Call getRookAttacks(square, occupancy) with current board occupancy
Mask out friendly pieces
For each set bit in resulting attack bitboard:
Determine if capture or quiet move
Create move and add to list
3.5 Queen Move Generation
 Get all queens for side to move
 For each queen:
Call getQueenAttacks(square, occupancy) (or combine bishop+rook attacks)
Mask out friendly pieces
For each set bit in resulting attack bitboard:
Determine if capture or quiet move
Create move and add to list
3.6 King Move Generation (non-castling)
 Get king for side to move (should be exactly 1)
 Use precomputed getKingAttacks(square) lookup
 Mask out friendly pieces
 For each set bit in resulting attack bitboard:
Determine if capture or quiet move
Create move and add to list
 Note: Don't filter out squares under attack yet (that's legal move filtering)
3.7 Castling Move Generation
 Kingside castling:
Check if side has kingside castling rights
Verify king is on starting square (e1 for white, e8 for black)
Verify kingside rook is on starting square (h1/h8)
Check f-file and g-file squares are empty
Create castling move from king square to g1/g8
 Queenside castling:
Check if side has queenside castling rights
Verify king is on starting square
Verify queenside rook is on starting square (a1/a8)
Check b-file, c-file, d-file squares are empty
Create castling move from king square to c1/c8
 Note: Don't check for attacks yet (that's legal move filtering)
3.8 MoveList Management
 Implement initMoveList(MoveList*) to set count to 0
 Implement addMove(MoveList*, Move) to append move
 Ensure MoveList has sufficient capacity (218 is theoretical max, 256 is safe)
 Add bounds checking or assert on moveList->count
Phase 4: Implement Make/Unmake Move Functions
4.1 Design Unmake Information Structure
 Create UndoInfo or BoardState struct to store:
Captured piece type (if any)
Previous castling rights (4 bools or 4 bits)
Previous en passant square
Previous halfmove clock
Previous position hash/key (if using Zobrist hashing later)
 Decide where to store undo info:
Return from makeMove?
Stack/array of undo info?
Part of move history in Board structure?
4.2 Implement makeMove() for Quiet Moves
 Extract from and to squares from move
 Identify which piece is moving (check all piece bitboards)
 Remove piece from source square
 Place piece on destination square
 Update appropriate bitboards (piece-specific and color occupancy)
 Recompute allPieces bitboard
 Increment halfmove clock
 Toggle side to move
 Clear en passant square (set to 64 or -1)
4.3 Implement makeMove() for Captures
 Identify captured piece type on destination square
 Store captured piece in undo info
 Remove captured piece from opponent's bitboards
 Remove moving piece from source
 Place moving piece on destination
 Update all relevant bitboards
 Reset halfmove clock to 0 (capture resets 50-move rule)
 Toggle side to move
 Clear en passant square
4.4 Implement makeMove() for Pawn Double Push
 Move pawn from source to destination (2 squares forward)
 Calculate en passant target square (square "behind" the pawn)
 Set board's epSquare to the target square
 Reset halfmove clock (pawn move resets 50-move rule)
 Toggle side to move
4.5 Implement makeMove() for En Passant
 Move pawn from source to en passant square
 Calculate captured pawn's square (same rank as source, same file as destination)
 Remove captured pawn from that square
 Update all relevant bitboards
 Reset halfmove clock
 Clear en passant square
 Toggle side to move
4.6 Implement makeMove() for Promotions
 Remove pawn from source square
 Place promoted piece (N/B/R/Q) on destination square
 If promotion capture, remove captured piece first
 Update appropriate bitboards
 Reset halfmove clock
 Clear en passant square
 Toggle side to move
4.7 Implement makeMove() for Castling
 Kingside:
Move king from e-file to g-file
Move rook from h-file to f-file
Update king and rook bitboards
 Queenside:
Move king from e-file to c-file
Move rook from a-file to d-file
Update king and rook bitboards
 Remove both kingside and queenside castling rights for this color
 Increment halfmove clock
 Clear en passant square
 Toggle side to move
4.8 Implement Castling Rights Updates
 If white king moves, clear both white castling rights
 If black king moves, clear both black castling rights
 If white rook on h1 moves or is captured, clear white kingside castling
 If white rook on a1 moves or is captured, clear white queenside castling
 If black rook on h8 moves or is captured, clear black kingside castling
 If black rook on a8 moves or is captured, clear black queenside castling
4.9 Implement Fullmove Number Updates
 Increment fullmove number after black moves
 Keep fullmove number same after white moves
4.10 Implement unmakeMove()
 Reverse all changes made by makeMove
 Move piece back from destination to source
 Restore captured piece (if any) from undo info
 Restore castling rights from undo info
 Restore en passant square from undo info
 Restore halfmove clock from undo info
 Decrement fullmove number if unmaking black's move
 Toggle side to move back
Phase 5: Implement Attack Detection & Legal Move Filtering
5.1 Implement isSquareAttacked() Function
 Input: board, square, attacking color
 Output: true/false if square is attacked
 Pawn attacks:
Generate pawn attacks FROM the square for the OPPOSITE color
Check if result intersects with attacking color's pawns
(This reverse-logic works because pawn attacks are symmetric)
 Knight attacks:
Generate knight attacks from the square
Check if intersects with attacking color's knights
 King attacks:
Generate king attacks from the square
Check if intersects with attacking color's king
 Bishop/diagonal attacks:
Generate bishop attacks from square with current occupancy
Check if intersects with attacking color's bishops OR queens
 Rook/orthogonal attacks:
Generate rook attacks from square with current occupancy
Check if intersects with attacking color's rooks OR queens
 Return true if ANY of above conditions are met
5.2 Implement isInCheck() Function
 Find king square for the specified color
 Call isSquareAttacked(board, kingSquare, opponentColor)
 Return the result
5.3 Implement Legal Move Filtering
 Create generateLegalMoves() function that:
Calls generateAllMoves() to get pseudo-legal moves
For each pseudo-legal move:
Make the move on a copy of the board (or use make/unmake)
Check if own king is in check after the move
If king is in check, discard the move (it's illegal)
If king is safe, keep the move
Return only the legal moves
5.4 Add Castling Legality Checks
 Additional checks for kingside castling:
King is not currently in check
f-file square is not attacked by opponent
g-file square is not attacked by opponent
(Squares e, f, g must all be safe)
 Additional checks for queenside castling:
King is not currently in check
d-file square is not attacked by opponent
c-file square is not attacked by opponent
(Squares e, d, c must all be safe, though b-file can be attacked)
 Integrate these checks into castling move generation
Phase 6: Implement Perft Testing Framework
6.1 Understand Perft Concept
 Research what perft is (performance test / path enumeration)
 Understand that perft(n) counts all possible positions at depth n
 Know that perft results are well-documented for test positions
 Understand perft is THE standard debugging tool for move generation
6.2 Implement Basic Perft Function
 Function signature: uint64_t perft(CBoard *board, int depth)
 Base case: if depth == 0, return 1 (one leaf node)
 Recursive case:
Generate all legal moves for current position
For each legal move:
Make the move
Recursively call perft(board, depth - 1)
Unmake the move
Add recursive result to total count
Return total count
6.3 Implement Divide Function (Perft Breakdown)
 Create divide(CBoard *board, int depth) function
 For each legal move from root position:
Make the move
Calculate perft(depth - 1) for resulting position
Unmake the move
Print move in algebraic notation and its perft count
 This helps identify which move type is generating wrong counts
6.4 Collect Standard Perft Test Positions
 Starting position: rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
perft(1) = 20
perft(2) = 400
perft(3) = 8,902
perft(4) = 197,281
perft(5) = 4,865,609
perft(6) = 119,060,324
 Kiwipete position: r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1
perft(1) = 48
perft(2) = 2,039
perft(3) = 97,862
perft(4) = 4,085,603
perft(5) = 193,690,690
 Position 3 (en passant): 8/2p5/3p4/KP5r/1R3p1k/8/4P1P1/8 w - - 0 1
 Position 4 (castling): r3k2r/Pppp1ppp/1b3nbN/nP6/BBP1P3/q4N2/Pp1P2PP/R2Q1RK1 w kq - 0 1
 Position 5 (promotions): rnbq1k1r/pp1Pbppp/2p5/8/2B5/8/PPP1NnPP/RNBQK2R w KQ - 1 8
 Position 6 (complex): r4rk1/1pp1qppp/p1np1n2/2b1p1B1/2B1P1b1/P1NP1N2/1PP1QPPP/R4RK1 w - - 0 10
6.5 Create Perft Test Suite
 Write test harness that runs perft on all test positions
 Compare results against known correct values
 Report which depth and position fails (if any)
 Add command-line option to run perft tests
6.6 Debug Failed Perft Results
 If perft fails:
Use divide() to see which moves produce wrong counts
Check if it's all moves or specific move types
Common bugs:
Pawns: double pushes, en passant, promotions
Castling: not checking all conditions
Move generation: missing or duplicate moves
Make/unmake: not restoring state correctly
Legal filtering: not catching all illegal moves
Phase 7: Utility & Debug Functions
7.1 Implement Move Printing Functions
 printMove(Move) - print move in coordinate notation (e2e4)
 moveToAlgebraic(Move, CBoard*, char*) - print in algebraic (Nf3, Bxe5+)
 printMoveList(MoveList*) - print all moves in a list
 Handle special notation:
Captures: x
Check: +
Checkmate: #
Castling: O-O and O-O-O
Promotions: =Q, =N, etc.
En passant: e.p. (optional)
7.2 Implement Board Printing with Move Highlights
 Add optional parameter to highlight from/to squares
 Print board with move's source square marked differently
 Print board with move's destination square marked differently
 Useful for debugging move application
7.3 Implement Move Validation Function
 isMovePseudoLegal(CBoard*, Move) - basic move format checking
 isMoveLegal(CBoard*, Move) - full legality check
 Useful for UCI/user input validation later
7.4 Add Debugging Macros
 Create DEBUG_PRINT() macro that can be toggled
 Add assertions for invariants:
Board has exactly 2 kings
No pawns on rank 1 or 8
Occupancy bitboards are consistent
 Add move validation in makeMove when debugging
Phase 8: Testing & Validation
8.1 Unit Test Each Piece Type
 Create positions with only one piece type
 Verify move counts match expected values
 Test edge cases (pieces on edges, corners)
8.2 Test Special Moves Individually
 Create positions testing:
Pawn double pushes
En passant captures
All promotion types (quiet and capture)
Kingside castling
Queenside castling
Castling with rook captured
Castling after king moves back
8.3 Test Make/Unmake Symmetry
 Make a move then unmake it
 Verify board returns to exact original state
 Test with all move types
 Verify FEN output is identical before/after
8.4 Run Full Perft Suite
 Run perft on all test positions to depth 5+
 Must match known-good values exactly
 If any fail, debug systematically using divide()
8.5 Test Repetition Detection (Optional for later)
 Track position history
 Detect threefold repetition
 Relevant for draw detection
Success Criteria
You'll know this phase is complete when:

 All perft tests pass to depth 5 on all standard test positions
 Move generation produces exactly the right number of moves
 Make/unmake is perfectly reversible for all move types
 No memory leaks or buffer overflows
 Code is well-commented and maintainable
 You can generate and apply moves from any legal chess position